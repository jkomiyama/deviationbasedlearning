# -*- coding: utf-8 -*-
"""DeviationBasedLearning.ipynb

Automatically generated by Colaboratory.

# Simulation of "Deviation-Based Learning" by Junpei Komiyama and Shunya Noda
"""

import numpy as np
np.random.seed(1) #fix random seed
import matplotlib
try:
    from google.colab import files
except: # https://stackoverflow.com/questions/35737116/runtimeerror-invalid-display-variable
    matplotlib.use('agg')
import matplotlib.pyplot as plt
from scipy.spatial import distance
from scipy import stats
from scipy.stats import truncnorm
import copy
import pickle

run_full = True # Test (small) or full (large)
save_img = True
def is_colab():
    try:
        from google.colab import files
        return True
    except:
        return False

Figsize = (6,4)
plt.rcParams["font.size"] = 14
plt.rcParams["axes.linewidth"] = 1
plt.rcParams["lines.linewidth"] = 2
plt.rcParams["figure.subplot.bottom"] = 0.14

COLOR_MODE3 = "tab:blue"
COLOR_MODE2 = "tab:red"
COLOR_TOTAL2 = COLOR_TOTAL3 = "black"
COLOR_FOLLOW2 = COLOR_FOLLOW3 = "#cc4c0b"
COLOR_NONFOLLOW2 = COLOR_NONFOLLOW3 = "navy"
COLOR_FENCE2 = COLOR_FENCE3 = "tab:green"

linestyle_tuple = {
     'loosely dotted':        (0, (1, 10)),
     'dotted':                (0, (1, 1)),
     'densely dotted':        (0, (1, 1)),

     'loosely dashed':        (0, (5, 10)),
     'dashed':                (0, (5, 5)),
     'densely dashed':        (0, (5, 1)),

     'loosely dashdotted':    (0, (3, 10, 1, 10)),
     'dashdotted':            (0, (3, 5, 1, 5)),
     'densely dashdotted':    (0, (3, 1, 1, 1)),

     'dashdotdotted':         (0, (3, 5, 1, 5, 1, 5)),
     'loosely dashdotdotted': (0, (3, 10, 1, 10, 1, 10)),
     'densely dashdotdotted': (0, (3, 1, 1, 1, 1, 1))
     }
LINESTYLE_MODE3 = "solid"
#COLOR_MODE2 = linestyle_tuple["densely dashed"]
LINESTYLE_MODE2 = "dashdot"
LINESTYLE_TOTAL2 = LINESTYLE_TOTAL3 = "solid"
LINESTYLE_FOLLOW2 = LINESTYLE_FOLLOW3 = "dashed"
#LINESTYLE_GREEDY = linestyle_tuple["densely dotted"]
LINESTYLE_NONFOLLOW2 = LINESTYLE_NONFOLLOW3 = linestyle_tuple["densely dotted"]
#LINESTYLE_ROONEY = "dashdot"
LINESTYLE_FENCE2 = LINESTYLE_FENCE3 = linestyle_tuple["densely dashdotted"]
#LINESTYLE_ROONEY_SWITCH = linestyle_tuple["densely dashdotted"]
#LINESTYLE_ROONEY_GREEDY = linestyle_tuple["densely dotted"]

#COLOR_CS_UCB = "navy"
#COLOR_HYBRID = "tab:orange"
#COLOR_CS_HYBRID = "#cc4c0b" 
#COLOR_ROONEY = "tab:blue"
#COLOR_ROONEY_SWITCH = "tab:green" 
#COLOR_ROONEY_GREEDY = "tab:red"

def my_show():
    try:
        from google.colab import files
        plt.show()
    except:
        pass
def colab_save(filename):
    try:
        from google.colab import files
        files.download(filename)  
    except:
        pass

a, b = -1., 1.
if run_full:
    T = 10000
    Runnum = 500 
else:
    T = 1000
    Runnum = 5 

# Binary signal
def round2(theta, a, b):
    z = np.random.normal()
    x = np.random.normal()
    c = (a+b)/2
    if x*c + z > 0: # recommend arm +1
        At = 1
        ez = truncnorm.stats(-x*c, -x*c+10000, moments='mvsk')[0] #mvsk = mean,variance,stddev,kurtosis
    else: # recommends arm -1
        At = -1
        ez = truncnorm.stats(-10000-x*c, -x*c, moments='mvsk')[0]
    if x*theta + ez > 0: # user choose arm 1
        It = 1
        if x>0:
            a_new = max(a, -ez/x)
            b_new = b
        else:
            a_new = a
            b_new = min(b, -ez/x)            
    else: # user choose arm -1
        It = -1
        if x>0:
            a_new = a
            b_new = min(b, -ez/x)
        else:
            a_new = max(a, -ez/x)
            b_new = b
    # regret increase
    if x*theta + z > 0 and It == -1:
        reg = x*theta + z
    elif x*theta + z < 0 and It == 1:
        reg = - ( x*theta + z )
    else:
        reg = 0
    updated = (a_new, b_new) != (a, b)
    # shrink of the confidence bound
    update_ratio = - np.log( (b_new - a_new) / (b - a) )
    non_followed = At != It
    return (a_new, b_new, reg, updated, update_ratio, non_followed)

# Ternary signal
def round3(theta, a, b, eps):
    z = np.random.normal()
    x = np.random.normal()
    c = (a+b)/2
    if abs(x*c + z) < eps: # recommends 0
        ez = truncnorm.stats(-x*c-eps, -x*c+eps, moments='mvsk')[0]
        At = 0
    elif x*c + z > 0: # recommends arm 1
        ez = truncnorm.stats(-x*c+eps, -x*c+10000, moments='mvsk')[0]
        At = 1
    else: # recommends arm -1
        ez = truncnorm.stats(-10000-x*c, -x*c-eps, moments='mvsk')[0]
        At = -1
    if x*theta + ez > 0: # user chooses arm 1
        It = 1
        if x>0:
            a_new = max(a, -ez/x)
            b_new = b
        else:
            a_new = a
            b_new = min(b, -ez/x)
    else: # user chooses arm -1
        It = -1
        if x>0:
            a_new = a
            b_new = min(b, -ez/x)
        else:
            a_new = max(a, -ez/x)
            b_new = b

    # regret計算
    if x*theta + z > 0 and It == 0:
        reg = x*theta + z
    elif x*theta + z < 0 and It == 1:
        reg = - ( x*theta + z )
    else:
        reg = 0

    updated = (a_new, b_new) != (a, b)
    update_ratio = - np.log( (b_new - a_new) / (b - a) )
    non_followed = At != It
    onthefence = At == 0
    return (a_new, b_new, reg, updated, update_ratio, non_followed, onthefence)

def main(mode3):
    print(f"mode3 = {mode3}")
    Regs = np.zeros((T, Runnum)) # Regret incurred each round and each run
    follow_update_num = np.zeros((T, Runnum)) # num of updates by following
    nonfollow_update_num = np.zeros((T, Runnum)) # num of updates by deviation
    fence_update_num = np.zeros((T, Runnum)) # num of updates by on the fence
    follow_update = np.zeros((T, Runnum)) # amount of updates by following
    nonfollow_update = np.zeros((T, Runnum)) # amount of updates by deviation
    fence_update = np.zeros((T, Runnum)) # amount of updates by on the fence

    for run in range(Runnum):
        a, b = -1, 1
        theta = -1 + 2 * np.random.uniform()
        print(f"theta = {theta}")
        tot_updated, tot_non_followed = 0, 0
        for t in range(T):
            if mode3:
                eps = 0.75 * (b-a) # on the fence width
                a, b, reg, updated, update_ratio, non_followed, onthefence = round3(theta, a, b, eps)
            else:
                a, b, reg, updated, update_ratio, non_followed = round2(theta, a, b)
                onthefence = False
                #print(f"a, b, reg, updated, update_ratio, non_followed = {a, b, reg, updated, update_ratio, non_followed}")
            if updated:
                if onthefence:
                    fence_update_num[t, run] = 1
                    fence_update[t, run] = update_ratio
                elif non_followed:
                    nonfollow_update_num[t, run] = 1
                    nonfollow_update[t, run] = update_ratio
                else:
                    follow_update_num[t, run] = 1
                    follow_update[t, run] = update_ratio
            Regs[t, run] = reg
        print(f"run = {run}, (a,b)=({a},{b}) d={b-a}")

    result = (Regs, follow_update_num, nonfollow_update_num, fence_update_num, follow_update, nonfollow_update, fence_update)
    return result

# e.g. 1,2,3,4 -> 1,3,6,10
def my_conv(anarray):
    if len(anarray.shape)>1: #assuming 1 or 2 dim
        T = anarray.shape[0]
        R = anarray.shape[1]
        temp = np.zeros(R)
        ret_array = np.zeros( (T, R) )
        for t in range(T):
            temp += anarray[t,:]
            ret_array[t,:] = temp
    else:
        T = anarray.shape[0]
        temp = 0 
        ret_array = np.zeros(T)
        for t in range(T):
            temp += anarray[t]
            ret_array[t] = temp
    return ret_array

# plotting
def my_plot(result_mode2, result_mode3, confidence_bound = True):
    LP, UP = 0.25, 0.75
    fig = plt.figure(figsize=Figsize)
    Regs_mode2 = my_conv(np.sum(result_mode2[0], axis=1)/Runnum)
    Regs_mode3 = my_conv(np.sum(result_mode3[0], axis=1)/Runnum)
    if confidence_bound:
        lower_quantile_regs_mode2 = np.quantile(my_conv(result_mode2[0]), LP, axis=1)
        upper_quantile_regs_mode2 = np.quantile(my_conv(result_mode2[0]), UP, axis=1)
        std_Regs_mode2 = np.std(my_conv(result_mode2[0]), axis=1)
        plt.errorbar([T], Regs_mode2[-1], yerr=2*std_Regs_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_MODE2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_regs_mode2, upper_quantile_regs_mode2, alpha=0.3, color = COLOR_MODE2)
        lower_quantile_regs_mode3 = np.quantile(my_conv(result_mode3[0]), LP, axis=1)
        upper_quantile_regs_mode3 = np.quantile(my_conv(result_mode3[0]), UP, axis=1)
        std_Regs_mode3 = np.std(my_conv(result_mode3[0]), axis=1)
        plt.errorbar([T], Regs_mode3[-1], yerr=2*std_Regs_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_MODE3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode3)+1), lower_quantile_regs_mode3, upper_quantile_regs_mode3, alpha=0.3, color = COLOR_MODE3)
    plt.plot(range(1, len(Regs_mode2)+1), Regs_mode2, label = "Binary", color = COLOR_MODE2, linestyle = LINESTYLE_MODE2)
    plt.plot(range(1, len(Regs_mode3)+1), Regs_mode3, label = "Ternary", color = COLOR_MODE3, linestyle = LINESTYLE_MODE3)
    plt.legend()
    plt.ylabel("Regret")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("regret.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("regret.pdf")
    plt.clf()
    fig = plt.figure(figsize=Figsize)
    if confidence_bound:
        plt.errorbar([T], Regs_mode2[-1], yerr=2*std_Regs_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_MODE2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_regs_mode2, upper_quantile_regs_mode2, alpha=0.3, color = COLOR_MODE2)
    plt.plot(range(1, len(Regs_mode2)+1), Regs_mode2, label = "Binary", color = COLOR_MODE2, linestyle = LINESTYLE_MODE2)
    plt.ylabel("Regret")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("regret2.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("regret2.pdf")
    plt.clf()
    fig = plt.figure(figsize=Figsize)
    if confidence_bound:
        plt.errorbar([T], Regs_mode3[-1], yerr=2*std_Regs_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_MODE3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode3)+1), lower_quantile_regs_mode3, upper_quantile_regs_mode3, alpha=0.3, color = COLOR_MODE3)
    plt.plot(range(1, len(Regs_mode3)+1), Regs_mode3, label = "Ternary", color = COLOR_MODE3, linestyle = LINESTYLE_MODE3)
    plt.ylabel("Regret")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("regret3.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("regret3.pdf")
    plt.clf()

    fig = plt.figure(figsize=Figsize)
    follow_update_num_mode2 = my_conv(np.sum(result_mode2[1], axis=1)/Runnum)
    nonfollow_update_num_mode2 = my_conv(np.sum(result_mode2[2], axis=1)/Runnum)
    total_update_num_mode2 = follow_update_num_mode2 + nonfollow_update_num_mode2
    if confidence_bound:
        lower_quantile_total_update_num_mode2 = np.quantile(my_conv(result_mode2[1]+result_mode2[2]), LP, axis=1)
        upper_quantile_total_update_num_mode2 = np.quantile(my_conv(result_mode2[1]+result_mode2[2]), UP, axis=1)
        std_total_update_num_mode2 = np.std(my_conv(result_mode2[1]+result_mode2[2]), axis=1)
        plt.errorbar([T], total_update_num_mode2[-1], yerr=2*std_total_update_num_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_TOTAL2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_total_update_num_mode2, upper_quantile_total_update_num_mode2, alpha=0.3, color = COLOR_TOTAL2)
        lower_quantile_follow_update_num_mode2 = np.quantile(my_conv(result_mode2[1]), LP, axis=1)
        upper_quantile_follow_update_num_mode2 = np.quantile(my_conv(result_mode2[1]), UP, axis=1)
        std_follow_update_num_mode2 = np.std(my_conv(result_mode2[1]), axis=1)
        plt.errorbar([T], follow_update_num_mode2[-1], yerr=2*std_follow_update_num_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FOLLOW2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_follow_update_num_mode2, upper_quantile_follow_update_num_mode2, alpha=0.3, color = COLOR_FOLLOW2)
        std_nonfollow_update_num_mode2 = np.std(my_conv(result_mode2[2]), axis=1)
        lower_quantile_nonfollow_update_num_mode2 = np.quantile(my_conv(result_mode2[2]), LP, axis=1)
        upper_quantile_nonfollow_update_num_mode2 = np.quantile(my_conv(result_mode2[2]), UP, axis=1)
        plt.errorbar([T], nonfollow_update_num_mode2[-1], yerr=2*std_nonfollow_update_num_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_NONFOLLOW2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_nonfollow_update_num_mode2, upper_quantile_nonfollow_update_num_mode2, alpha=0.3, color = COLOR_NONFOLLOW2)
    plt.plot(range(1, len(Regs_mode2)+1), total_update_num_mode2, label = "Total", color = COLOR_TOTAL2, linestyle = LINESTYLE_TOTAL2)
    plt.plot(range(1, len(Regs_mode2)+1), follow_update_num_mode2, label = "Obey", color = COLOR_FOLLOW2, linestyle = LINESTYLE_FOLLOW2)
    plt.plot(range(1, len(Regs_mode2)+1), nonfollow_update_num_mode2, label = "Deviate", color = COLOR_NONFOLLOW2, linestyle = LINESTYLE_NONFOLLOW2)
    plt.legend()
    plt.ylabel("Number of Updates")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("update_num2.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("update_num2.pdf")
    plt.clf()

    fig = plt.figure(figsize=Figsize)
    follow_update_num_mode3 = my_conv(np.sum(result_mode3[1], axis=1)/Runnum)
    nonfollow_update_num_mode3 = my_conv(np.sum(result_mode3[2], axis=1)/Runnum)
    fence_update_num_mode3 = my_conv(np.sum(result_mode3[3], axis=1)/Runnum)
    total_update_num_mode3 = follow_update_num_mode3 + nonfollow_update_num_mode3 + fence_update_num_mode3
    if confidence_bound:
        #lower_quantile_total_update_num_mode3 = np.quantile(my_conv(result_mode3[1]+result_mode3[2]+result_mode3[3]), LP, axis=1)
        #upper_quantile_total_update_num_mode3 = np.quantile(my_conv(result_mode3[1]+result_mode3[2]+result_mode3[3]), UP, axis=1)
        #std_total_update_num_mode3 = np.std(my_conv(result_mode3[1]+result_mode3[2]+result_mode3[3]), axis=1)
        #plt.errorbar([T], total_update_num_mode3[-1], yerr=2*std_total_update_num_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_TOTAL3) #2 sigma
        #plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_total_update_num_mode3, upper_quantile_total_update_num_mode3, alpha=0.3, color = COLOR_TOTAL3)
        lower_quantile_follow_update_num_mode3 = np.quantile(my_conv(result_mode3[1]), LP, axis=1)
        upper_quantile_follow_update_num_mode3 = np.quantile(my_conv(result_mode3[1]), UP, axis=1)
        std_follow_update_num_mode3 = np.std(my_conv(result_mode3[1]), axis=1)
        plt.errorbar([T], follow_update_num_mode3[-1], yerr=2*std_follow_update_num_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FOLLOW3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_follow_update_num_mode3, upper_quantile_follow_update_num_mode3, alpha=0.3, color = COLOR_FOLLOW3)
        std_nonfollow_update_num_mode3 = np.std(my_conv(result_mode3[2]), axis=1)
        lower_quantile_nonfollow_update_num_mode3 = np.quantile(my_conv(result_mode3[2]), LP, axis=1)
        upper_quantile_nonfollow_update_num_mode3 = np.quantile(my_conv(result_mode3[2]), UP, axis=1)
        plt.errorbar([T], nonfollow_update_num_mode3[-1], yerr=2*std_nonfollow_update_num_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_NONFOLLOW3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_nonfollow_update_num_mode3, upper_quantile_nonfollow_update_num_mode3, alpha=0.3, color = COLOR_NONFOLLOW3)
        std_fence_update_num_mode3 = np.std(my_conv(result_mode3[3]), axis=1)
        lower_quantile_fence_update_num_mode3 = np.quantile(my_conv(result_mode3[3]), LP, axis=1)
        upper_quantile_fence_update_num_mode3 = np.quantile(my_conv(result_mode3[3]), UP, axis=1)
        plt.errorbar([T], fence_update_num_mode3[-1], yerr=2*std_fence_update_num_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FENCE3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_fence_update_num_mode3, upper_quantile_fence_update_num_mode3, alpha=0.3, color = COLOR_FENCE3)
    #plt.plot(range(1, len(Regs_mode3)+1), follow_update_num_mode3 + nonfollow_update_num_mode3 + fence_update_num_mode3, label = "ACC(t)", color = COLOR_TOTAL3, linestyle = LINESTYLE_TOTAL3)
    plt.plot(range(1, len(Regs_mode3)+1), follow_update_num_mode3, label = "Obey", color = COLOR_FOLLOW3, linestyle = LINESTYLE_FOLLOW3)
    plt.plot(range(1, len(Regs_mode3)+1), nonfollow_update_num_mode3, label = "Deviate", color = COLOR_NONFOLLOW3, linestyle = LINESTYLE_NONFOLLOW3)
    plt.plot(range(1, len(Regs_mode3)+1), fence_update_num_mode3, label = "OtF", color = COLOR_FENCE3, linestyle = LINESTYLE_FENCE3)
    plt.legend()
    plt.ylabel("Number of Updates")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("update_num3.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("update_num3.pdf")
    plt.clf()

    fig = plt.figure(figsize=Figsize)
    follow_update_mode2 = my_conv(np.sum(result_mode2[4], axis=1)/Runnum)
    nonfollow_update_mode2 = my_conv(np.sum(result_mode2[5], axis=1)/Runnum)
    total_update_mode2 = follow_update_mode2 + nonfollow_update_mode2
    if confidence_bound:
        lower_quantile_total_update_mode2 = np.quantile(my_conv(result_mode2[4]+result_mode2[5]), LP, axis=1)
        upper_quantile_total_update_mode2 = np.quantile(my_conv(result_mode2[4]+result_mode2[5]), UP, axis=1)
        std_total_update_mode2 = np.std(my_conv(result_mode2[4]+result_mode2[5]), axis=1)
        plt.errorbar([T], total_update_mode2[-1], yerr=2*std_total_update_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_TOTAL2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_total_update_mode2, upper_quantile_total_update_mode2, alpha=0.3, color = COLOR_TOTAL2)
        lower_quantile_follow_update_mode2 = np.quantile(my_conv(result_mode2[4]), LP, axis=1)
        upper_quantile_follow_update_mode2 = np.quantile(my_conv(result_mode2[4]), UP, axis=1)
        std_follow_update_mode2 = np.std(my_conv(result_mode2[4]), axis=1)
        plt.errorbar([T], follow_update_mode2[-1], yerr=2*std_follow_update_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FOLLOW2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_follow_update_mode2, upper_quantile_follow_update_mode2, alpha=0.3, color = COLOR_FOLLOW2)
        std_nonfollow_update_mode2 = np.std(my_conv(result_mode2[5]), axis=1)
        lower_quantile_nonfollow_update_mode2 = np.quantile(my_conv(result_mode2[5]), LP, axis=1)
        upper_quantile_nonfollow_update_mode2 = np.quantile(my_conv(result_mode2[5]), UP, axis=1)
        plt.errorbar([T], nonfollow_update_mode2[-1], yerr=2*std_nonfollow_update_mode2[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_NONFOLLOW2) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_nonfollow_update_mode2, upper_quantile_nonfollow_update_mode2, alpha=0.3, color = COLOR_NONFOLLOW2)
    plt.plot(range(1, len(Regs_mode2)+1), follow_update_mode2 + nonfollow_update_mode2, label = "ACC(t)", color = COLOR_TOTAL2, linestyle = LINESTYLE_TOTAL2)
    plt.plot(range(1, len(Regs_mode2)+1), follow_update_mode2, label = "ACC(t)_Obey", color = COLOR_FOLLOW2, linestyle = LINESTYLE_FOLLOW2)
    plt.plot(range(1, len(Regs_mode2)+1), nonfollow_update_mode2, label = "ACC(t)_Deviate", color = COLOR_NONFOLLOW2, linestyle = LINESTYLE_NONFOLLOW2)
    plt.legend()
    plt.ylabel("Amount of update")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("update2.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("update2.pdf")
    plt.clf()

    fig = plt.figure(figsize=Figsize)
    follow_update_mode3 = my_conv(np.sum(result_mode3[4], axis=1)/Runnum)
    nonfollow_update_mode3 = my_conv(np.sum(result_mode3[5], axis=1)/Runnum)
    fence_update_mode3 = my_conv(np.sum(result_mode3[6], axis=1)/Runnum)
    total_update_mode3 = follow_update_mode3 + nonfollow_update_mode3 + fence_update_mode3
    if confidence_bound:
        #lower_quantile_total_update_mode3 = np.quantile(my_conv(result_mode3[4]+result_mode3[5]+result_mode3[6]), LP, axis=1)
        #upper_quantile_total_update_mode3 = np.quantile(my_conv(result_mode3[4]+result_mode3[5]+result_mode3[6]), UP, axis=1)
        #std_total_update_mode3 = np.std(my_conv(result_mode3[4]+result_mode3[5]+result_mode3[6]), axis=1)
        #plt.errorbar([T], total_update_mode3[-1], yerr=2*std_total_update_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_TOTAL3) #2 sigma
        #plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_total_update_mode3, upper_quantile_total_update_mode3, alpha=0.3, color = COLOR_TOTAL3)
        lower_quantile_follow_update_mode3 = np.quantile(my_conv(result_mode3[4]), LP, axis=1)
        upper_quantile_follow_update_mode3 = np.quantile(my_conv(result_mode3[4]), UP, axis=1)
        std_follow_update_mode3 = np.std(my_conv(result_mode3[4]), axis=1)
        plt.errorbar([T], follow_update_mode3[-1], yerr=2*std_follow_update_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FOLLOW3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_follow_update_mode3, upper_quantile_follow_update_mode3, alpha=0.3, color = COLOR_FOLLOW3)
        std_nonfollow_update_mode3 = np.std(my_conv(result_mode3[5]), axis=1)
        lower_quantile_nonfollow_update_mode3 = np.quantile(my_conv(result_mode3[5]), LP, axis=1)
        upper_quantile_nonfollow_update_mode3 = np.quantile(my_conv(result_mode3[5]), UP, axis=1)
        plt.errorbar([T], nonfollow_update_mode3[-1], yerr=2*std_nonfollow_update_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_NONFOLLOW3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_nonfollow_update_mode3, upper_quantile_nonfollow_update_mode3, alpha=0.3, color = COLOR_NONFOLLOW3)
        std_fence_update_mode3 = np.std(my_conv(result_mode3[6]), axis=1)
        lower_quantile_fence_update_mode3 = np.quantile(my_conv(result_mode3[6]), LP, axis=1)
        upper_quantile_fence_update_mode3 = np.quantile(my_conv(result_mode3[6]), UP, axis=1)
        plt.errorbar([T], fence_update_mode3[-1], yerr=2*std_fence_update_mode3[-1]/np.sqrt(Runnum), fmt='o', capsize = 5, color = COLOR_FENCE3) #2 sigma
        plt.fill_between(range(1, len(Regs_mode2)+1), lower_quantile_fence_update_mode3, upper_quantile_fence_update_mode3, alpha=0.3, color = COLOR_FENCE3)
    #plt.plot(range(1, len(Regs_mode3)+1), follow_update_mode3 + nonfollow_update_mode3+ fence_update_mode3, label = "ACC(t)", color = COLOR_TOTAL3, linestyle = LINESTYLE_TOTAL3)
    plt.plot(range(1, len(Regs_mode3)+1), follow_update_mode3, label = "ACC(t)_Obey", color = COLOR_FOLLOW3, linestyle = LINESTYLE_FOLLOW3)
    plt.plot(range(1, len(Regs_mode3)+1), nonfollow_update_mode3, label = "ACC(t)_Deviate", color = COLOR_NONFOLLOW3, linestyle = LINESTYLE_NONFOLLOW3)
    plt.plot(range(1, len(Regs_mode3)+1), fence_update_mode3, label = "ACC(t)_OtF", color = COLOR_FENCE3, linestyle = LINESTYLE_FENCE3)
    plt.legend()
    plt.ylabel("Amount of update")
    plt.xlabel("Round (t)")
    my_show()
    if save_img:
        fig.savefig("update3.pdf", dpi=fig.dpi, bbox_inches='tight')
        colab_save("update3.pdf")
    plt.clf()

result_mode2 = main(mode3 = False)
result_mode3 = main(mode3 = True)

my_plot(result_mode2, result_mode3)